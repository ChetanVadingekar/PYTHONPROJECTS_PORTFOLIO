@eventsession_blueprint.route('/api/v1/eventSessions/filters', methods=['GET'])
@cognito_auth_required
@authorization_required(perms={"list:eventSessionsFilters"})
def list_event_session_filters() -> ResponseReturnValue:
    """
    Fetch filter options for filtering EventSession entries.

    Returns:
        (ResponseReturnValue): filter options list and status code.
    """
    try:
        params = validate_query_params(
            ['page', 'filter_level', 'project_name', 'generation']
        )
        
        generation = f"{float(params['generation']):0.1f}"        

        event_session_index_name = fetch_project_name_table(
            params['project_name'], "event_session_table_name"
        )

        filter_attributes = fetch_filter_attributes(
            params['page'], params['filter_level']
        )

        common_attributes = filter_attributes['common_attributes']
        gen_key = f'gen_attributes_{generation}'
        if gen_key not in filter_attributes:
            raise KeyError("Filter attributes not found")
        gen_attributes = filter_attributes[gen_key]

        response = {**common_attributes, **gen_attributes}
        final_response = append_vehicle_ids(
            response,
            event_session_index_name,
            filter_key="split_status",
            filter_value="SUCCESS",
        )
        logging.info(
            f"dynamoDB response for fetching filter "
            f"attributes: {final_response}"
        )
        return (
            jsonify(final_response),
            200,
        )
    except ValueError as e:
        logging.error(f"Validation Error: {str(e)}")
        return (
            jsonify({'message': str(e)}),
            400,
        )
    except KeyError as e:
        error_message = str(e).strip('\'"')
        logging.error(f"KeyError occurred: {error_message}")
        return (
            jsonify({'message': error_message}),
            404,
        )
    except botocore.exceptions.ClientError as e:
        logging.error(f"DynamoDB ClientError: {str(e)}")
        return (
            jsonify({'message': "An error occured while querying DynamoDB"}),
            500,
        )
    except Exception as e:
        logging.exception(f"An error occurred: {str(e)}")
        return jsonify({"message": str(e)}), 500


There is one corner case we have to handle when generation is not castable like TypeError.

